diff -Naur xen/tools/blktap/drivers/Makefile xen-a/tools/blktap/drivers/Makefile
--- xen/tools/blktap/drivers/Makefile	2014-07-07 23:11:48.423334436 -0600
+++ xen-a/tools/blktap/drivers/Makefile	2014-07-08 06:14:54.263332595 -0600
@@ -32,8 +32,9 @@
 CFLAGS += $(PTHREAD_CFLAGS)
 LDFLAGS += $(PTHREAD_LDFLAGS)
 
-LDLIBS_blktapctrl := $(MEMSHRLIBS) $(LDLIBS_libxenctrl) $(LDLIBS_libxenstore) -L../lib -lblktap -lrt -lm $(PTHREAD_LIBS)
-LDLIBS_img := $(AIOLIBS) $(CRYPT_LIB) $(PTHREAD_LIBS) -lz
+LDLIBS_xen := $(LDLIBS_libxenctrl) $(LDLIBS_libxenstore)
+LDLIBS_blktapctrl := $(MEMSHRLIBS) $(LDLIBS_xen) -L../lib -lblktap -lrt -lm $(PTHREAD_LIBS)
+LDLIBS_img := $(AIOLIBS) $(CRYPT_LIB) $(PTHREAD_LIBS) -lz $(LDLIBS_xen)
 
 BLK-OBJS-y  := block-aio.o
 BLK-OBJS-y  += block-sync.o
@@ -41,6 +42,7 @@
 BLK-OBJS-y  += block-ram.o
 BLK-OBJS-y  += block-qcow.o
 BLK-OBJS-y  += block-qcow2.o
+BLK-OBJS-y  += block-cdrom.o
 BLK-OBJS-y  += aes.o
 BLK-OBJS-y  += tapaio.o
 BLK-OBJS-$(CONFIG_Linux) += blk_linux.o
diff -Naur xen/tools/blktap/drivers/block-cdrom.c xen-a/tools/blktap/drivers/block-cdrom.c
--- xen/tools/blktap/drivers/block-cdrom.c	1969-12-31 17:00:00.000000000 -0700
+++ xen-a/tools/blktap/drivers/block-cdrom.c	2014-07-08 06:14:54.263332595 -0600
@@ -0,0 +1,568 @@
+/* block-cdrom.c
+ *
+ * simple slow synchronous cdrom disk implementation. Based off
+ * of block-sync.c
+ *
+ * (c) 2006 Andrew Warfield and Julian Chesterfield
+ * (c) 2008 Novell Inc. <plc@novell.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation; or, when distributed
+ * separately from the Linux kernel or incorporated into other
+ * software packages, subject to the following license:
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this source file (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/statvfs.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/mount.h>
+
+#include "tapdisk.h"
+#include <xen/io/cdromif.h>
+
+struct tdcdrom_state {
+	int fd;
+	int xs_fd;        /* for xen event polling */
+	int media_present;
+	int media_changed;
+	struct xs_handle *xs_handle;
+	char *dev_name;
+	int dev_type;
+	td_flag_t flags;
+};
+
+#define BLOCK_DEVICE   0
+#define FILE_DEVICE    1
+#define CDROM_DEFAULT_SECTOR_SIZE 2048
+#define CDROM_DEFAULT_SIZE 2000000000
+
+/*Get Image size, secsize*/
+static void get_image_info(struct disk_driver *dd)
+{
+	int ret;
+	long size;
+	unsigned long total_size;
+	struct statvfs statBuf;
+	struct stat stat;
+	struct td_state     *s   = dd->td_state;
+	struct tdcdrom_state *prv = dd->private;
+
+	s->size = 0;
+	s->sector_size = CDROM_DEFAULT_SECTOR_SIZE;
+	s->info = (VDISK_CDROM | VDISK_REMOVABLE | VDISK_READONLY);
+	prv->media_present = 0;
+
+	ret = fstat(prv->fd, &stat);
+	if (ret != 0) {
+		DPRINTF("ERROR: fstat failed, Couldn't stat image");
+		return;
+	}
+
+	if (S_ISBLK(stat.st_mode)) {
+		/*Accessing block device directly*/
+		int status;
+
+		prv->dev_type = BLOCK_DEVICE;
+		status = ioctl(prv->fd, CDROM_DRIVE_STATUS, CDSL_CURRENT);
+		if (status == CDS_DISC_OK) {
+			prv->media_present = 1;
+			if ((ret =ioctl(prv->fd,BLKGETSIZE,&s->size))!=0) {
+				DPRINTF("ERR: BLKGETSIZE failed, couldn't stat image");
+				s->size = CDROM_DEFAULT_SIZE;
+			}
+		}
+		else {
+			s->size = CDROM_DEFAULT_SIZE;
+		}
+		/*Get the sector size*/
+#if defined(BLKSSZGET)
+		{
+			int arg;
+			s->sector_size = CDROM_DEFAULT_SECTOR_SIZE;
+			ioctl(prv->fd, BLKSSZGET, &s->sector_size);
+
+			if (s->sector_size != CDROM_DEFAULT_SECTOR_SIZE)
+				DPRINTF("Note: sector size is %llu (not %d)\n",
+					(long long unsigned)s->sector_size,
+					CDROM_DEFAULT_SECTOR_SIZE);
+		}
+#else
+		s->sector_size = CDROM_DEFAULT_SECTOR_SIZE;
+#endif
+		DPRINTF("Block Device: Image size: %llu"
+			" media_present: %d sector_size: %llu\n",
+			(long long unsigned)s->size, prv->media_present,
+			(long long unsigned)s->sector_size);
+	} else {
+		/*Local file? try fstat instead*/
+		prv->dev_type = FILE_DEVICE;
+		prv->media_present = 1;
+		s->size = (stat.st_size >> SECTOR_SHIFT);
+		s->sector_size = DEFAULT_SECTOR_SIZE;
+		DPRINTF("Local File: Image size: %llu\n",
+				(long long unsigned)s->size);
+	}
+	return;
+}
+
+static inline void init_fds(struct disk_driver *dd)
+{
+	int i;
+	struct tdcdrom_state *prv = dd->private;
+
+	for(i = 0; i < MAX_IOFD; i++)
+		dd->io_fd[i] = 0;
+
+	prv->xs_handle = xs_daemon_open();
+	prv->xs_fd = xs_fileno(prv->xs_handle);
+	dd->io_fd[0] = prv->xs_fd;
+}
+
+void open_device (struct disk_driver *dd)
+{
+	struct tdcdrom_state *prv = dd->private;
+	int o_flags;
+
+	o_flags = O_NONBLOCK | O_LARGEFILE |
+		((prv->flags == TD_RDONLY) ? O_RDONLY : O_RDWR);
+
+	if (prv->fd < 0) {
+		prv->fd = open(prv->dev_name, o_flags);
+		if (prv->fd == -1) {
+			DPRINTF("Unable tp open: (%s)\n", prv->dev_name);
+			return;
+		}
+	}
+
+	if (prv->fd != -1) {
+
+		get_image_info(dd);
+
+		if (prv->dev_type == BLOCK_DEVICE) {
+			int status;
+			status = ioctl(prv->fd, CDROM_DRIVE_STATUS, CDSL_CURRENT);
+			switch (status) {
+				case CDS_DISC_OK:
+					prv->media_present = 1;
+					break;
+				default:
+					prv->media_present = 0;
+			}
+		}
+		else
+			prv->media_present = 1;
+	}
+}
+
+/*
+ * Main entry point, called when first loaded
+ */
+int tdcdrom_open (struct disk_driver *dd, const char *name, td_flag_t flags)
+{
+	int ret;
+	struct tdcdrom_state *prv = dd->private;
+
+	ret = asprintf(&prv->dev_name, "%s", name);
+	if (ret < 0) {
+		prv->dev_name = NULL;
+		goto out;
+	}
+	prv->fd = -1;
+	prv->media_changed = 0;
+	prv->media_present = 0;
+	prv->flags = flags;
+	init_fds(dd);
+
+	open_device(dd);
+
+out:
+	return ret;
+}
+
+int tdcdrom_queue_read(struct disk_driver *dd, uint64_t sector,
+		int nb_sectors, char *buf, td_callback_t cb,
+		int id, void *private)
+{
+	struct td_state     *s   = dd->td_state;
+	struct tdcdrom_state *prv = dd->private;
+	int      size    = nb_sectors * s->sector_size;
+	uint64_t offset  = sector * (uint64_t)s->sector_size;
+	int ret;
+
+	if (prv->fd == -1 || prv->media_present == 0) {
+		ret = 0 - ENOMEDIUM;
+		return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+	}
+	size    = nb_sectors * 512;
+	offset  = sector * (uint64_t)512;
+	ret = lseek(prv->fd, offset, SEEK_SET);
+	if (ret != (off_t)-1) {
+		ret = read(prv->fd, buf, size);
+		if (ret != size) {
+			ret = 0 - errno;
+		} else {
+			ret = 1;
+		}
+	} else ret = 0 - errno;
+
+	return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+}
+
+int tdcdrom_queue_write(struct disk_driver *dd, uint64_t sector,
+		int nb_sectors, char *buf, td_callback_t cb,
+		int id, void *private)
+{
+	struct td_state     *s   = dd->td_state;
+	struct tdcdrom_state *prv = dd->private;
+	int      size    = nb_sectors * s->sector_size;
+	uint64_t offset  = sector * (uint64_t)s->sector_size;
+	int ret = 0;
+
+	if (prv->fd == -1 || prv->media_present == 0) {
+		ret = 0 - ENOMEDIUM;
+		return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+	}
+	ret = lseek(prv->fd, offset, SEEK_SET);
+	if (ret != (off_t)-1) {
+		ret = write(prv->fd, buf, size);
+		if (ret != size) {
+			ret = 0 - errno;
+		} else {
+			ret = 1;
+		}
+	} else ret = 0 - errno;
+
+	return cb(dd, (ret < 0) ? ret : 0, sector, nb_sectors, id, private);
+}
+
+int tdcdrom_queue_packet(struct disk_driver *dd, uint64_t sector,
+		int nb_sectors, char *buf, td_callback_t cb,
+		int id, void *private)
+{
+	struct td_state     *s   = dd->td_state;
+	struct tdcdrom_state *prv = dd->private;
+	int      size    = nb_sectors * s->sector_size;
+	uint64_t offset  = sector * (uint64_t)s->sector_size;
+	int ret = 0;
+
+	union xen_block_packet *sp;
+	struct xen_cdrom_packet *xcp;
+	struct xen_cdrom_support *xcs;
+	struct xen_cdrom_open *xco;
+	struct xen_cdrom_media_info *xcmi;
+	struct xen_cdrom_media_changed *xcmc;
+	struct cdrom_generic_command cgc;
+	struct vcd_generic_command * vgc;
+	struct request_sense sense;
+
+	sp = (union xen_block_packet *)buf;
+	switch(sp->type) {
+		case XEN_TYPE_CDROM_SUPPORT:
+			xcs = &(sp->xcs);
+			xcs->err = 0;
+			xcs->ret = 0;
+			xcs->supported = 1;
+			break;
+		case XEN_TYPE_CDROM_PACKET:
+			xcp = &(sp->xcp);
+			xcp->err = 0;
+			xcp->ret = 0;
+			vgc = (struct vcd_generic_command *)(buf + PACKET_PAYLOAD_OFFSET);
+
+			memset( &cgc, 0, sizeof(struct cdrom_generic_command));
+			memcpy(cgc.cmd, vgc->cmd, CDROM_PACKET_SIZE);
+			cgc.stat = vgc->stat;
+			cgc.data_direction = vgc->data_direction;
+			cgc.quiet = vgc->quiet;
+			cgc.timeout = vgc->timeout;
+
+			if (prv->fd == -1) {
+				xcp = &(sp->xcp);
+				xcp->ret = -1;
+				xcp->err =  0 - ENODEV;
+				return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+			}
+			if (prv->dev_type == FILE_DEVICE) {
+				DPRINTF("%s() FILE_DEVICE inappropriate packetcmd \n",__func__);
+				return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+			}
+			switch ( cgc.cmd[0]) {
+				case GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL:
+					{
+						int lock;
+						lock = cgc.cmd[4] & 1;
+						if (ioctl (prv->fd, CDROM_LOCKDOOR, lock) < 0) {
+							xcp->err = -(errno);
+							xcp->ret = -1;
+						}
+					}
+					break;
+				case GPCMD_START_STOP_UNIT:
+					{
+						int start, eject;
+						start = cgc.cmd[4] & 1;
+						eject = (cgc.cmd[4] >> 1) & 1;
+						if (eject && !start) {
+							if (ioctl (prv->fd, CDROMEJECT, NULL) < 0) {
+								xcp->err = -(errno);
+								xcp->ret = -1;
+							}
+						} else if (eject && start) {
+							if (ioctl (prv->fd, CDROMCLOSETRAY, NULL) < 0) {
+								xcp->err = -(errno);
+								xcp->ret = -1;
+							}
+						}
+					}
+					break;
+				default:
+					{
+						if (vgc->sense_offset) {
+							cgc.sense = &sense;
+						}
+						if (vgc->buffer_offset) {
+							cgc.buffer = malloc(vgc->buflen);
+							memcpy(cgc.buffer, (char *)sp + PACKET_BUFFER_OFFSET, vgc->buflen);
+							cgc.buflen = vgc->buflen;
+						}
+						if (ioctl (prv->fd, CDROM_SEND_PACKET, &cgc) < 0 ) {
+							xcp->err = -(errno);
+							xcp->ret = -1;
+						}
+						if (cgc.sense) {
+							memcpy((char *)sp + PACKET_SENSE_OFFSET, cgc.sense, sizeof(struct request_sense));
+						}
+						if (cgc.buffer) {
+							vgc->buflen = cgc.buflen;
+							memcpy((char *)sp + PACKET_BUFFER_OFFSET, cgc.buffer, cgc.buflen);
+							free(cgc.buffer);
+						}
+						break;
+					}
+			}
+			break;
+		case XEN_TYPE_CDROM_OPEN:
+			{
+				unsigned int len;
+				struct stat statbuf;
+				int major = 0;
+				int minor = 0;
+
+				if (stat (prv->dev_name, &statbuf) == 0) {
+					major = major (statbuf.st_rdev);
+					minor = minor (statbuf.st_rdev);
+				}
+				xco = &(sp->xco);
+				xco->err = 0;
+				xco->ret = 0;
+				if (xco->payload_offset) {
+					char *present;
+					char *buf;
+					char *num;
+					char *nodename;
+					char media_present[2];
+					nodename = (char *)sp + xco->payload_offset;
+					if (asprintf(&buf, "%s/media-present", nodename) < 0)
+						goto out_payload_offset;
+					present = xs_read(prv->xs_handle, XBT_NULL, buf, &len);
+					if (present) {
+						free(buf);
+						goto out_payload_offset_free;
+					}
+
+					sprintf(media_present, "%d", prv->media_present);
+					xs_write(prv->xs_handle, XBT_NULL, buf, media_present, strlen(media_present));
+					xs_watch(prv->xs_handle, buf, "media-present");
+					free(buf);
+
+					if (asprintf(&buf, "%s/params", nodename) < 0)
+						goto out_payload_offset_free;
+					xs_watch(prv->xs_handle, buf, "params");
+					free(buf);
+
+					if (asprintf(&num, "%x:%x", major, minor) < 0)
+						goto out_payload_offset_free;
+					if (asprintf(&buf, "%s/physical-device", nodename) < 0) {
+						free(num);
+						goto out_payload_offset_free;
+					}
+					xs_write(prv->xs_handle, XBT_NULL, buf, num, strlen(num));
+					free(buf);
+					free(num);
+out_payload_offset_free:
+					free(present);
+out_payload_offset:
+					;
+				}
+
+				xco->media_present = prv->media_present;
+				xco->sectors = 0;
+				xco->sector_size = 2048;
+				if (prv->media_present && prv->fd != -1 ) {
+					get_image_info(dd);
+					xco->sectors = s->size;
+					xco->sector_size = s->sector_size;
+				}
+			}
+			break;
+		case XEN_TYPE_CDROM_MEDIA_CHANGED:
+			xcmc = &(sp->xcmc);
+			xcmc->err = 0;
+			xcmc->ret = 0;
+			xcmc->media_changed = prv->media_changed;
+			prv->media_changed = 0;
+			break;
+		default:
+			xcp = &(sp->xcp);
+			xcp->err = -EINVAL;
+			xcp->ret = -1;
+			break;
+	}
+
+	return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+}
+
+int tdcdrom_submit(struct disk_driver *dd)
+{
+	return 0;
+}
+
+int tdcdrom_close(struct disk_driver *dd)
+{
+	struct tdcdrom_state *prv = dd->private;
+
+	if (prv->fd != -1) {
+		close(prv->fd);
+		prv->fd = -1;
+	}
+	prv->xs_fd = -1;
+	xs_daemon_close(prv->xs_handle);
+	free(prv->dev_name);
+
+	return 0;
+}
+
+void tdcdrom_process_media_change_event(struct disk_driver *dd, char **vec)
+{
+    struct tdcdrom_state *prv = dd->private;
+    char *media_present;
+    unsigned int len;
+
+	media_present = xs_read(prv->xs_handle, XBT_NULL, vec[XS_WATCH_PATH], &len);
+    if (media_present == NULL)
+        return;
+
+	if (strcmp(media_present, "0") == 0) {
+		close(prv->fd);
+		prv->fd = -1;
+		prv->media_present = 0;
+	}
+	else {
+		open_device(dd);
+		prv->media_changed = 1;
+	}
+	free(media_present);
+}
+
+void tdcrom_process_params_event(struct disk_driver *dd, char **vec)
+{
+    struct tdcdrom_state *prv = dd->private;
+    char *params;
+    unsigned int len;
+
+	params = xs_read(prv->xs_handle, XBT_NULL, vec[XS_WATCH_PATH], &len);
+	if (params) {
+		char *cp = strchr(params, ':');
+		if (cp) {
+			cp++;
+			if (prv->dev_name)
+				free(prv->dev_name);
+			if (asprintf(&prv->dev_name, "%s", cp) < 0) {
+				prv->dev_name = NULL;
+				return;
+			}
+			if (prv->fd != -1) {
+				close(prv->fd);
+				prv->fd = -1;
+			}
+			open_device(dd);
+			prv->media_changed = 1;
+		}
+		free(params);
+	}
+}
+
+int tdcdrom_do_callbacks(struct disk_driver *dd, int sid)
+{
+	struct tdcdrom_state *prv = dd->private;
+	char **vec;
+	unsigned int num;
+
+	vec = xs_read_watch(prv->xs_handle, &num);
+	if (!vec)
+		return 1;
+
+    if (!strcmp(vec[XS_WATCH_TOKEN], "media-present")) {
+        tdcdrom_process_media_change_event(dd, vec);
+        goto out;
+    }
+
+    if (!strcmp(vec[XS_WATCH_TOKEN], "params")) {
+        tdcrom_process_params_event(dd, vec);
+        goto out;
+    }
+
+ out:
+    free(vec);
+	return 1;
+}
+
+int tdcdrom_get_parent_id(struct disk_driver *dd, struct disk_id *id)
+{
+	return TD_NO_PARENT;
+}
+
+int tdcdrom_validate_parent(struct disk_driver *dd,
+		struct disk_driver *parent, td_flag_t flags)
+{
+	return -EINVAL;
+}
+
+struct tap_disk tapdisk_cdrom = {
+	.disk_type           = "tapdisk_cdrom",
+	.private_data_size   = sizeof(struct tdcdrom_state),
+	.td_open             = tdcdrom_open,
+	.td_queue_read       = tdcdrom_queue_read,
+	.td_queue_packet     = tdcdrom_queue_packet,
+	.td_queue_write      = tdcdrom_queue_write,
+	.td_submit           = tdcdrom_submit,
+	.td_close            = tdcdrom_close,
+	.td_do_callbacks     = tdcdrom_do_callbacks,
+	.td_get_parent_id    = tdcdrom_get_parent_id,
+	.td_validate_parent  = tdcdrom_validate_parent
+};
diff -Naur xen/tools/blktap/drivers/tapdisk.c xen-a/tools/blktap/drivers/tapdisk.c
--- xen/tools/blktap/drivers/tapdisk.c	2014-07-07 23:11:48.426667770 -0600
+++ xen-a/tools/blktap/drivers/tapdisk.c	2014-07-08 06:14:54.263332595 -0600
@@ -735,6 +735,22 @@
 					goto out;
 				}
 				break;
+			case BLKIF_OP_PACKET:
+				ret = 0;
+				if (drv->td_queue_packet)
+					ret = drv->td_queue_packet(dd, sector_nr,
+							nsects, page,
+							send_responses,
+							idx, (void *)(long)i);
+				if (ret > 0) dd->early += ret;
+				else if (ret == -EBUSY) {
+					/* put req back on queue */
+					--info->fe_ring.req_cons;
+					info->busy.req     = req;
+					info->busy.seg_idx = i;
+					goto out;
+				}
+				break;
 			default:
 				DPRINTF("Unknown block operation\n");
 				break;
diff -Naur xen/tools/blktap/drivers/tapdisk.h xen-a/tools/blktap/drivers/tapdisk.h
--- xen/tools/blktap/drivers/tapdisk.h	2014-07-07 23:11:48.426667770 -0600
+++ xen-a/tools/blktap/drivers/tapdisk.h	2014-07-08 06:15:31.046666669 -0600
@@ -137,6 +137,9 @@
 	int (*td_get_parent_id)  (struct disk_driver *dd, struct disk_id *id);
 	int (*td_validate_parent)(struct disk_driver *dd, 
 				  struct disk_driver *p, td_flag_t flags);
+	int (*td_queue_packet)  (struct disk_driver *dd, uint64_t sector,
+				  int nb_sectors, char *buf, td_callback_t cb,
+				  int id, void *prv);
 };
 
 typedef struct disk_info {
@@ -160,6 +163,7 @@
 extern struct tap_disk tapdisk_ram;
 extern struct tap_disk tapdisk_qcow;
 extern struct tap_disk tapdisk_qcow2;
+extern struct tap_disk tapdisk_cdrom;
 
 
 /*Define Individual Disk Parameters here */
@@ -168,7 +172,7 @@
 	"raw image (aio)",
 	"aio",
 	0,
-	0,
+	1,
 #ifdef TAPDISK
 	&tapdisk_aio,
 #endif
@@ -179,7 +183,7 @@
 	"raw image (sync)",
 	"sync",
 	0,
-	0,
+	1,
 #ifdef TAPDISK
 	&tapdisk_sync,
 #endif
@@ -190,7 +194,7 @@
 	"vmware image (vmdk)",
 	"vmdk",
 	1,
-	0,
+	1,
 #ifdef TAPDISK
 	&tapdisk_vmdk,
 #endif
@@ -212,7 +216,7 @@
 	"qcow disk (qcow)",
 	"qcow",
 	0,
-	0,
+	1,
 #ifdef TAPDISK
 	&tapdisk_qcow,
 #endif
@@ -223,12 +227,23 @@
 	"qcow2 disk (qcow2)",
 	"qcow2",
 	0,
-	0,
+	1,
 #ifdef TAPDISK
 	&tapdisk_qcow2,
 #endif
 };
 
+static disk_info_t cdrom_disk = {
+	DISK_TYPE_CDROM,
+	"raw image (cdrom)",
+	"cdrom",
+	0,
+	0,
+#ifdef TAPDISK
+	&tapdisk_cdrom,
+#endif
+};
+
 /*Main disk info array */
 static disk_info_t *dtypes[] = {
 	&aio_disk,
@@ -237,6 +252,7 @@
 	&ram_disk,
 	&qcow_disk,
 	&qcow2_disk,
+	&cdrom_disk,
 };
 
 typedef struct driver_list_entry {
diff -Naur xen/tools/blktap/drivers/tapdisk.h.orig xen-a/tools/blktap/drivers/tapdisk.h.orig
--- xen/tools/blktap/drivers/tapdisk.h.orig	1969-12-31 17:00:00.000000000 -0700
+++ xen-a/tools/blktap/drivers/tapdisk.h.orig	2014-07-08 06:14:54.263332595 -0600
@@ -0,0 +1,275 @@
+/* tapdisk.h
+ *
+ * Generic disk interface for blktap-based image adapters.
+ *
+ * (c) 2006 Andrew Warfield and Julian Chesterfield
+ * 
+ * Some notes on the tap_disk interface:
+ * 
+ * tap_disk aims to provide a generic interface to easily implement new 
+ * types of image accessors.  The structure-of-function-calls is similar
+ * to disk interfaces used in qemu/denali/etc, with the significant 
+ * difference being the expectation of asynchronous rather than synchronous 
+ * I/O.  The asynchronous interface is intended to allow lots of requests to
+ * be pipelined through a disk, without the disk requiring any of its own
+ * threads of control.  As such, a batch of requests is delivered to the disk
+ * using:
+ * 
+ *    td_queue_[read,write]()
+ * 
+ * and passing in a completion callback, which the disk is responsible for 
+ * tracking.  The end of a back is marked with a call to:
+ * 
+ *    td_submit()
+ * 
+ * The disk implementation must provide a file handle, which is used to 
+ * indicate that it needs to do work.  tapdisk will add this file handle 
+ * (returned from td_get_fd()) to it's poll set, and will call into the disk
+ * using td_do_callbacks() whenever there is data pending.
+ * 
+ * Two disk implementations demonstrate how this interface may be used to 
+ * implement disks with both asynchronous and synchronous calls.  block-aio.c
+ * maps this interface down onto the linux libaio calls, while block-sync uses 
+ * normal posix read/write.
+ * 
+ * A few things to realize about the sync case, which doesn't need to defer 
+ * io completions:
+ * 
+ *   - td_queue_[read,write]() call read/write directly, and then call the 
+ *     callback immediately.  The MUST then return a value greater than 0
+ *     in order to tell tapdisk that requests have finished early, and to 
+ *     force responses to be kicked to the clents.
+ * 
+ *   - The fd used for poll is an otherwise unused pipe, which allows poll to 
+ *     be safely called without ever returning anything.
+ *
+ * NOTE: tapdisk uses the number of sectors submitted per request as a 
+ * ref count.  Plugins must use the callback function to communicate the
+ * completion--or error--of every sector submitted to them.
+ *
+ * td_get_parent_id returns:
+ *     0 if parent id successfully retrieved
+ *     TD_NO_PARENT if no parent exists
+ *     -errno on error
+ */
+
+#ifndef TAPDISK_H_
+#define TAPDISK_H_
+
+#include <stdint.h>
+#include <syslog.h>
+#include <stdio.h>
+#include "blktaplib.h"
+
+/*If enabled, log all debug messages to syslog*/
+#if 1
+#define DPRINTF(_f, _a...) syslog( LOG_DEBUG, __FILE__ ":%d: " _f , __LINE__, ## _a )
+#else
+#define DPRINTF(_f, _a...) ((void)0)
+#endif
+
+/* Things disks need to know about, these should probably be in a higher-level
+ * header. */
+#define MAX_SEGMENTS_PER_REQ    11
+#define SECTOR_SHIFT             9
+#define DEFAULT_SECTOR_SIZE    512
+
+#define MAX_IOFD                 2
+
+#define BLK_NOT_ALLOCATED       99
+#define TD_NO_PARENT             1
+
+typedef uint32_t td_flag_t;
+
+#define TD_RDONLY                1
+
+struct td_state;
+struct tap_disk;
+
+struct disk_id {
+	char *name;
+	int drivertype;
+};
+
+struct disk_driver {
+	int early;
+	char *name;
+	void *private;
+	td_flag_t flags;
+	int io_fd[MAX_IOFD];
+	struct tap_disk *drv;
+	struct td_state *td_state;
+	struct disk_driver *next;
+};
+
+/* This structure represents the state of an active virtual disk.           */
+struct td_state {
+	struct disk_driver *disks;
+	void *blkif;
+	void *image;
+	void *ring_info;
+	void *fd_entry;
+	uint64_t sector_size;
+	uint64_t size;
+	unsigned int       info;
+};
+
+/* Prototype of the callback to activate as requests complete.              */
+typedef int (*td_callback_t)(struct disk_driver *dd, int res, uint64_t sector,
+			     int nb_sectors, int id, void *private);
+
+/* Structure describing the interface to a virtual disk implementation.     */
+/* See note at the top of this file describing this interface.              */
+struct tap_disk {
+	const char *disk_type;
+	int private_data_size;
+	int (*td_open)           (struct disk_driver *dd, 
+				  const char *name, td_flag_t flags);
+	int (*td_queue_read)     (struct disk_driver *dd, uint64_t sector,
+				  int nb_sectors, char *buf, td_callback_t cb,
+				  int id, void *prv);
+	int (*td_queue_write)    (struct disk_driver *dd, uint64_t sector,
+				  int nb_sectors, char *buf, td_callback_t cb, 
+				  int id, void *prv);
+	int (*td_submit)         (struct disk_driver *dd);
+	int (*td_close)          (struct disk_driver *dd);
+	int (*td_do_callbacks)   (struct disk_driver *dd, int sid);
+	int (*td_get_parent_id)  (struct disk_driver *dd, struct disk_id *id);
+	int (*td_validate_parent)(struct disk_driver *dd, 
+				  struct disk_driver *p, td_flag_t flags);
+	int (*td_queue_packet)  (struct disk_driver *dd, uint64_t sector,
+				  int nb_sectors, char *buf, td_callback_t cb,
+				  int id, void *prv);
+};
+
+typedef struct disk_info {
+	int  idnum;
+	char name[50];       /* e.g. "RAMDISK" */
+	char handle[10];     /* xend handle, e.g. 'ram' */
+	int  single_handler; /* is there a single controller for all */
+	                     /* instances of disk type? */
+	int  use_ioemu;      /* backend provider: 0 = tapdisk; 1 = ioemu */
+
+#ifdef TAPDISK
+	struct tap_disk *drv;	
+#endif
+} disk_info_t;
+
+void debug_fe_ring(struct td_state *s);
+
+extern struct tap_disk tapdisk_aio;
+extern struct tap_disk tapdisk_sync;
+extern struct tap_disk tapdisk_vmdk;
+extern struct tap_disk tapdisk_ram;
+extern struct tap_disk tapdisk_qcow;
+extern struct tap_disk tapdisk_qcow2;
+extern struct tap_disk tapdisk_cdrom;
+
+
+/*Define Individual Disk Parameters here */
+static disk_info_t aio_disk = {
+	DISK_TYPE_AIO,
+	"raw image (aio)",
+	"aio",
+	0,
+	0,
+#ifdef TAPDISK
+	&tapdisk_aio,
+#endif
+};
+
+static disk_info_t sync_disk = {
+	DISK_TYPE_SYNC,
+	"raw image (sync)",
+	"sync",
+	0,
+	0,
+#ifdef TAPDISK
+	&tapdisk_sync,
+#endif
+};
+
+static disk_info_t vmdk_disk = {
+	DISK_TYPE_VMDK,
+	"vmware image (vmdk)",
+	"vmdk",
+	1,
+	0,
+#ifdef TAPDISK
+	&tapdisk_vmdk,
+#endif
+};
+
+static disk_info_t ram_disk = {
+	DISK_TYPE_RAM,
+	"ramdisk image (ram)",
+	"ram",
+	1,
+	0,
+#ifdef TAPDISK
+	&tapdisk_ram,
+#endif
+};
+
+static disk_info_t qcow_disk = {
+	DISK_TYPE_QCOW,
+	"qcow disk (qcow)",
+	"qcow",
+	0,
+	0,
+#ifdef TAPDISK
+	&tapdisk_qcow,
+#endif
+};
+
+static disk_info_t qcow2_disk = {
+	DISK_TYPE_QCOW2,
+	"qcow2 disk (qcow2)",
+	"qcow2",
+	0,
+	0,
+#ifdef TAPDISK
+	&tapdisk_qcow2,
+#endif
+};
+
+static disk_info_t cdrom_disk = {
+	DISK_TYPE_CDROM,
+	"raw image (cdrom)",
+	"cdrom",
+	0,
+	0,
+#ifdef TAPDISK
+	&tapdisk_cdrom,
+#endif
+};
+
+/*Main disk info array */
+static disk_info_t *dtypes[] = {
+	&aio_disk,
+	&sync_disk,
+	&vmdk_disk,
+	&ram_disk,
+	&qcow_disk,
+	&qcow2_disk,
+	&cdrom_disk,
+};
+
+typedef struct driver_list_entry {
+	struct blkif *blkif;
+	struct driver_list_entry **pprev, *next;
+} driver_list_entry_t;
+
+typedef struct fd_list_entry {
+	int cookie;
+	int  tap_fd;
+	struct td_state *s;
+	struct fd_list_entry **pprev, *next;
+} fd_list_entry_t;
+
+int qcow_create(const char *filename, uint64_t total_size,
+		const char *backing_file, int flags);
+
+int qcow2_create(const char *filename, uint64_t total_size,
+		const char *backing_file, int flags);
+#endif /*TAPDISK_H_*/
diff -Naur xen/tools/blktap/lib/blktaplib.h xen-a/tools/blktap/lib/blktaplib.h
--- xen/tools/blktap/lib/blktaplib.h	2014-07-07 23:11:48.426667770 -0600
+++ xen-a/tools/blktap/lib/blktaplib.h	2014-07-08 06:14:54.263332595 -0600
@@ -219,6 +219,7 @@
 #define DISK_TYPE_RAM      3
 #define DISK_TYPE_QCOW     4
 #define DISK_TYPE_QCOW2    5
+#define DISK_TYPE_CDROM    6
 
 /* xenstore/xenbus: */
 #define DOMNAME "Domain-0"
diff -Naur xen/tools/console/client/main.c xen-a/tools/console/client/main.c
--- xen/tools/console/client/main.c	2014-07-07 23:11:48.440001104 -0600
+++ xen-a/tools/console/client/main.c	2014-07-08 06:12:48.280007687 -0600
@@ -95,6 +95,7 @@
  * Assumes there is already a watch set in the store for this path. */
 {
 	struct timeval tv;
+	struct flock lock;
 	fd_set watch_fdset;
 	int xs_fd = xs_fileno(xs), pty_fd = -1;
 	int start, now;
@@ -118,6 +119,14 @@
 				pty_fd = open(pty_path, O_RDWR | O_NOCTTY);
 				if (pty_fd == -1)
 					warn("Could not open tty `%s'", pty_path);
+				else {
+					memset(&lock, 0, sizeof(lock));
+					lock.l_type = F_WRLCK;
+					lock.l_whence = SEEK_SET;
+					if (fcntl(pty_fd, F_SETLK, &lock) != 0)
+						err(errno, "Could not lock tty '%s'",
+						    pty_path);
+				}
 			}
 			free(pty_path);
 		}
diff -Naur xen/tools/console/client/main.c.orig xen-a/tools/console/client/main.c.orig
--- xen/tools/console/client/main.c.orig	1969-12-31 17:00:00.000000000 -0700
+++ xen-a/tools/console/client/main.c.orig	2014-07-07 23:11:48.440001104 -0600
@@ -0,0 +1,400 @@
+/*\
+ *  Copyright (C) International Business Machines  Corp., 2005
+ *  Author(s): Anthony Liguori <aliguori@us.ibm.com>
+ *
+ *  Xen Console Daemon
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; under version 2 of the License.
+ * 
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ * 
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+\*/
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <time.h>
+#include <fcntl.h>
+#include <sys/wait.h>
+#include <termios.h>
+#include <signal.h>
+#include <getopt.h>
+#include <sys/select.h>
+#include <err.h>
+#include <string.h>
+#ifdef __sun__
+#include <sys/stropts.h>
+#endif
+
+#include <xenstore.h>
+#include "xenctrl.h"
+
+#define ESCAPE_CHARACTER 0x1d
+
+static volatile sig_atomic_t received_signal = 0;
+
+static void sighandler(int signum)
+{
+	received_signal = 1;
+}
+
+static bool write_sync(int fd, const void *data, size_t size)
+{
+	size_t offset = 0;
+	ssize_t len;
+
+	while (offset < size) {
+		len = write(fd, data + offset, size - offset);
+		if (len < 1) {
+			return false;
+		}
+		offset += len;
+	}
+
+	return true;
+}
+
+static void usage(const char *program) {
+	printf("Usage: %s [OPTION] DOMID\n"
+	       "Attaches to a virtual domain console\n"
+	       "\n"
+	       "  -h, --help       display this help and exit\n"
+	       "  -n, --num N      use console number N\n"
+	       , program);
+}
+
+#ifdef	__sun__
+void cfmakeraw(struct termios *termios_p)
+{
+	termios_p->c_iflag &=
+	    ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL|IXON);
+	termios_p->c_oflag &= ~OPOST;
+	termios_p->c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);
+	termios_p->c_cflag &= ~(CSIZE|PARENB);
+	termios_p->c_cflag |= CS8;
+
+	termios_p->c_cc[VMIN] = 0;
+	termios_p->c_cc[VTIME] = 0;
+}
+#endif
+
+static int get_pty_fd(struct xs_handle *xs, char *path, int seconds)
+/* Check for a pty in xenstore, open it and return its fd.
+ * Assumes there is already a watch set in the store for this path. */
+{
+	struct timeval tv;
+	fd_set watch_fdset;
+	int xs_fd = xs_fileno(xs), pty_fd = -1;
+	int start, now;
+	unsigned int len = 0;
+	char *pty_path, **watch_paths;
+
+	start = now = time(NULL);
+	do {
+		tv.tv_usec = 0;
+		tv.tv_sec = (start + seconds) - now;
+		FD_ZERO(&watch_fdset);
+		FD_SET(xs_fd, &watch_fdset);
+		if (select(xs_fd + 1, &watch_fdset, NULL, NULL, &tv)) {
+			/* Read the watch to drain the buffer */
+			watch_paths = xs_read_watch(xs, &len);
+			free(watch_paths);
+			/* We only watch for one thing, so no need to 
+			 * disambiguate: just read the pty path */
+			pty_path = xs_read(xs, XBT_NULL, path, &len);
+			if (pty_path != NULL && pty_path[0] != '\0') {
+				pty_fd = open(pty_path, O_RDWR | O_NOCTTY);
+				if (pty_fd == -1)
+					warn("Could not open tty `%s'", pty_path);
+			}
+			free(pty_path);
+		}
+	} while (pty_fd == -1 && (now = time(NULL)) < start + seconds);
+
+#ifdef __sun__
+	if (pty_fd != -1) {
+		struct termios term;
+
+		/*
+		 * The pty may come from either xend (with pygrub) or
+		 * xenconsoled.  It may have tty semantics set up, or not.
+		 * While it isn't strictly necessary to have those
+		 * semantics here, it is good to have a consistent
+		 * state that is the same as under Linux.
+		 *
+		 * If tcgetattr fails, they have not been set up,
+		 * so go ahead and set them up now, by pushing the
+		 * ptem and ldterm streams modules.
+		 */
+		if (tcgetattr(pty_fd, &term) < 0) {
+			ioctl(pty_fd, I_PUSH, "ptem");
+			ioctl(pty_fd, I_PUSH, "ldterm");
+		}
+	}
+#endif
+
+	return pty_fd;
+}
+
+
+/* don't worry too much if setting terminal attributes fail */
+static void init_term(int fd, struct termios *old)
+{
+	struct termios new_term;
+
+	if (tcgetattr(fd, old) == -1)
+		return;
+
+	new_term = *old;
+	cfmakeraw(&new_term);
+
+	tcsetattr(fd, TCSANOW, &new_term);
+}
+
+static void restore_term(int fd, struct termios *old)
+{
+	tcsetattr(fd, TCSANOW, old);
+}
+
+static int console_loop(int fd, struct xs_handle *xs, char *pty_path)
+{
+	int ret, xs_fd = xs_fileno(xs), max_fd;
+
+	do {
+		fd_set fds;
+
+		FD_ZERO(&fds);
+		FD_SET(STDIN_FILENO, &fds);
+		max_fd = STDIN_FILENO;
+		FD_SET(xs_fd, &fds);
+		if (xs_fd > max_fd) max_fd = xs_fd;
+		if (fd != -1) FD_SET(fd, &fds);
+		if (fd > max_fd) max_fd = fd;
+
+		ret = select(max_fd + 1, &fds, NULL, NULL, NULL);
+		if (ret == -1) {
+			if (errno == EINTR || errno == EAGAIN) {
+				continue;
+			}
+			return -1;
+		}
+
+		if (FD_ISSET(xs_fileno(xs), &fds)) {
+			int newfd = get_pty_fd(xs, pty_path, 0);
+			if (fd != -1)
+				close(fd);
+                        if (newfd == -1) 
+				/* Console PTY has become invalid */
+				return 0;
+			fd = newfd;
+			continue;
+		}
+
+		if (FD_ISSET(STDIN_FILENO, &fds)) {
+			ssize_t len;
+			char msg[60];
+
+			len = read(STDIN_FILENO, msg, sizeof(msg));
+			if (len == 1 && msg[0] == ESCAPE_CHARACTER) {
+				return 0;
+			} 
+
+			if (len == 0 || len == -1) {
+				if (len == -1 &&
+				    (errno == EINTR || errno == EAGAIN)) {
+					continue;
+				}
+				return -1;
+			}
+
+			if (!write_sync(fd, msg, len)) {
+				close(fd);
+				fd = -1;
+				continue;
+			}
+		}
+
+		if (fd != -1 && FD_ISSET(fd, &fds)) {
+			ssize_t len;
+			char msg[512];
+
+			len = read(fd, msg, sizeof(msg));
+			if (len == 0 || len == -1) {
+				if (len == -1 &&
+				    (errno == EINTR || errno == EAGAIN)) {
+					continue;
+				}
+				close(fd);
+				fd = -1;
+				continue;
+			}
+
+			if (!write_sync(STDOUT_FILENO, msg, len)) {
+				perror("write() failed");
+				return -1;
+			}
+		}
+	} while (received_signal == 0);
+
+	return 0;
+}
+
+typedef enum {
+       CONSOLE_INVAL,
+       CONSOLE_PV,
+       CONSOLE_SERIAL,
+} console_type;
+
+static struct termios stdin_old_attr;
+
+static void restore_term_stdin(void)
+{
+	restore_term(STDIN_FILENO, &stdin_old_attr);
+}
+
+int main(int argc, char **argv)
+{
+	struct termios attr;
+	int domid;
+	char *sopt = "hn:";
+	int ch;
+	unsigned int num = 0;
+	int opt_ind=0;
+	struct option lopt[] = {
+		{ "type",     1, 0, 't' },
+		{ "num",     1, 0, 'n' },
+		{ "help",    0, 0, 'h' },
+		{ 0 },
+
+	};
+	char *dom_path = NULL, *path = NULL;
+	int spty, xsfd;
+	struct xs_handle *xs;
+	char *end;
+	console_type type = CONSOLE_INVAL;
+
+	while((ch = getopt_long(argc, argv, sopt, lopt, &opt_ind)) != -1) {
+		switch(ch) {
+		case 'h':
+			usage(argv[0]);
+			exit(0);
+			break;
+		case 'n':
+			num = atoi(optarg);
+			break;
+		case 't':
+			if (!strcmp(optarg, "serial"))
+				type = CONSOLE_SERIAL;
+			else if (!strcmp(optarg, "pv"))
+				type = CONSOLE_PV;
+			else {
+				fprintf(stderr, "Invalid type argument\n");
+				fprintf(stderr, "Console types supported are: serial, pv\n");
+				exit(EINVAL);
+			}
+			break;
+		default:
+			fprintf(stderr, "Invalid argument\n");
+			fprintf(stderr, "Try `%s --help' for more information.\n", 
+					argv[0]);
+			exit(EINVAL);
+		}
+	}
+
+	if (optind >= argc) {
+		fprintf(stderr, "DOMID should be specified\n");
+		fprintf(stderr, "Try `%s --help' for more information.\n",
+			argv[0]);
+		exit(EINVAL);
+	}
+	domid = strtol(argv[optind], &end, 10);
+	if (end && *end) {
+		fprintf(stderr, "Invalid DOMID `%s'\n", argv[optind]);
+		fprintf(stderr, "Try `%s --help' for more information.\n",
+			argv[0]);
+		exit(EINVAL);
+	}
+
+	xs = xs_daemon_open();
+	if (xs == NULL) {
+		err(errno, "Could not contact XenStore");
+	}
+
+	signal(SIGTERM, sighandler);
+
+	dom_path = xs_get_domain_path(xs, domid);
+	if (dom_path == NULL)
+		err(errno, "xs_get_domain_path()");
+	if (type == CONSOLE_INVAL) {
+		xc_dominfo_t xcinfo;
+		xc_interface *xc_handle = xc_interface_open(0,0,0);
+		if (xc_handle == NULL)
+			err(errno, "Could not open xc interface");
+		if ( (xc_domain_getinfo(xc_handle, domid, 1, &xcinfo) != 1) ||
+		     (xcinfo.domid != domid) ) {
+			xc_interface_close(xc_handle);
+			err(errno, "Failed to get domain information");
+		}
+		/* default to pv console for pv guests and serial for hvm guests */
+		if (xcinfo.hvm)
+			type = CONSOLE_SERIAL;
+		else
+			type = CONSOLE_PV;
+		xc_interface_close(xc_handle);
+	}
+	path = malloc(strlen(dom_path) + strlen("/device/console/0/tty") + 5);
+	if (path == NULL)
+		err(ENOMEM, "malloc");
+	if (type == CONSOLE_SERIAL)
+		snprintf(path, strlen(dom_path) + strlen("/serial/0/tty") + 5, "%s/serial/%d/tty", dom_path, num);
+	else {
+		if (num == 0)
+			snprintf(path, strlen(dom_path) + strlen("/console/tty") + 1, "%s/console/tty", dom_path);
+		else
+			snprintf(path, strlen(dom_path) + strlen("/device/console/%d/tty") + 5, "%s/device/console/%d/tty", dom_path, num);
+	}
+
+	/* FIXME consoled currently does not assume domain-0 doesn't have a
+	   console which is good when we break domain-0 up.  To keep us
+	   user friendly, we'll bail out here since no data will ever show
+	   up on domain-0. */
+	if (domid == 0) {
+		fprintf(stderr, "Can't specify Domain-0\n");
+		exit(EINVAL);
+	}
+
+	/* Set a watch on this domain's console pty */
+	if (!xs_watch(xs, path, ""))
+		err(errno, "Can't set watch for console pty");
+	xsfd = xs_fileno(xs);
+
+	/* Wait a little bit for tty to appear.  There is a race
+	   condition that occurs after xend creates a domain.  This code
+	   might be running before consoled has noticed the new domain
+	   and setup a pty for it. */ 
+        spty = get_pty_fd(xs, path, 5);
+	if (spty == -1) {
+		err(errno, "Could not read tty from store");
+	}
+
+	init_term(spty, &attr);
+	init_term(STDIN_FILENO, &stdin_old_attr);
+	atexit(restore_term_stdin); /* if this fails, oh dear */
+	console_loop(spty, xs, path);
+
+	free(path);
+	free(dom_path);
+	return 0;
+ }
diff -Naur xen/tools/firmware/etherboot/Config xen-a/tools/firmware/etherboot/Config
--- xen/tools/firmware/etherboot/Config	2014-07-07 23:11:48.443334436 -0600
+++ xen-a/tools/firmware/etherboot/Config	2014-07-08 06:16:45.083331332 -0600
@@ -1,3 +1,4 @@
+NICS = rtl8139 8086100e eepro100 e1000 pcnet32 10ec8029
 
 CFLAGS += -UPXE_DHCP_STRICT
 CFLAGS += -DPXE_DHCP_STRICT
diff -Naur xen/tools/python/xen/xend/server/HalDaemon.py xen-a/tools/python/xen/xend/server/HalDaemon.py
--- xen/tools/python/xen/xend/server/HalDaemon.py	1969-12-31 17:00:00.000000000 -0700
+++ xen-a/tools/python/xen/xend/server/HalDaemon.py	2014-07-08 06:10:03.136669044 -0600
@@ -0,0 +1,243 @@
+#!/usr/bin/env python
+#  -*- mode: python; -*-
+#============================================================================
+# This library is free software; you can redistribute it and/or
+# modify it under the terms of version 2.1 of the GNU Lesser General Public
+# License as published by the Free Software Foundation.
+#
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with this library; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#============================================================================
+# Copyright (C) 2007 Pat Campbell <plc@novell.com>
+# Copyright (C) 2007 Novell Inc.
+#============================================================================
+
+"""hald (Hardware Abstraction Layer Daemon) watcher for Xen management
+   of removable block device media.
+
+"""
+
+import gobject
+import dbus
+import dbus.glib
+import os
+import types
+import sys
+import signal
+import traceback
+from xen.xend.xenstore.xstransact import xstransact, complete
+from xen.xend.xenstore.xsutil import xshandle
+from xen.xend import PrettyPrint
+from xen.xend import XendLogging
+from xen.xend.XendLogging import log
+
+DEVICE_TYPES = ['vbd', 'tap']
+
+class HalDaemon:
+    """The Hald block device watcher for XEN
+    """
+
+    """Default path to the log file. """
+    logfile_default = "/var/log/xen/hald.log"
+
+    """Default level of information to be logged."""
+    loglevel_default = 'INFO'
+
+
+    def __init__(self):
+
+        XendLogging.init(self.logfile_default, self.loglevel_default)
+        log.debug( "%s", "__init__")
+
+        self.udi_dict = {}
+        self.debug = 0
+        self.dbpath = "/local/domain/0/backend"
+        self.bus = dbus.SystemBus()
+        self.hal_manager_obj = self.bus.get_object('org.freedesktop.Hal', '/org/freedesktop/Hal/Manager')
+        self.hal_manager = dbus.Interface( self.hal_manager_obj, 'org.freedesktop.Hal.Manager')
+        self.gatherBlockDevices()
+        self.registerDeviceCallbacks()
+
+    def run(self):
+        log.debug( "%s", "In new run" );
+        try:
+            self.mainloop = gobject.MainLoop()
+            self.mainloop.run()
+        except KeyboardInterrupt, ex:
+            log.debug('Keyboard exception handler: %s', ex )
+            self.mainloop.quit()
+        except Exception, ex:
+            log.debug('Generic exception handler: %s', ex )
+            self.mainloop.quit()
+
+    def __del__(self):
+        log.debug( "%s", "In del " );
+        self.unRegisterDeviceCallbacks()
+        self.mainloop.quit()
+
+    def shutdown(self):
+        log.debug( "%s", "In shutdown now " );
+        self.unRegisterDeviceCallbacks()
+        self.mainloop.quit()
+
+    def stop(self):
+        log.debug( "%s", "In stop now " );
+        self.unRegisterDeviceCallbacks()
+        self.mainloop.quit()
+
+    def gatherBlockDevices(self):
+
+        # Get all the current devices from hal and save in a dictionary
+        try:
+            device_names = self.hal_manager.GetAllDevices()
+            i = 0;
+            for name in device_names:
+                #log.debug("device name, device=%s",name)
+               dev_obj = self.bus.get_object ('org.freedesktop.Hal', name)
+               dev = dbus.Interface (dev_obj, 'org.freedesktop.Hal.Device')
+               dev_properties = dev_obj.GetAllProperties(dbus_interface="org.freedesktop.Hal.Device")
+               if dev_properties.has_key('block.device'):
+                   dev_str = dev_properties['block.device']
+                   dev_major = dev_properties['block.major']
+                   dev_minor = dev_properties['block.minor']
+                   udi_info = {}
+                   udi_info['device'] = dev_str
+                   udi_info['major'] = dev_major
+                   udi_info['minor'] = dev_minor
+                   udi_info['udi'] = name
+                   self.udi_dict[i] = udi_info
+                   i = i + 1
+        except Exception, ex:
+            print >>sys.stderr, 'Exception gathering block devices:', ex
+            log.warn("Exception gathering block devices (%s)",ex)
+
+    #
+    def registerDeviceCallbacks(self):
+        # setup the callbacks for when the gdl changes
+        self.hal_manager.connect_to_signal('DeviceAdded', self.device_added_callback)
+        self.hal_manager.connect_to_signal('DeviceRemoved', self.device_removed_callback)
+
+    #
+    def unRegisterDeviceCallbacks(self):
+        # setup the callbacks for when the gdl changes
+        self.hal_manager.remove_signal_receiver(self.device_added_callback,'DeviceAdded')
+        self.hal_manager.remove_signal_receiver(self.device_removed_callback,'DeviceRemoved')
+
+    #
+    def device_removed_callback(self,udi):
+        log.debug('UDI %s was removed',udi)
+        self.show_dict(self.udi_dict)
+        for key in self.udi_dict:
+            udi_info = self.udi_dict[key]
+            if udi_info['udi'] == udi:
+                device = udi_info['device']
+                major = udi_info['major']
+                minor = udi_info['minor']
+                self.change_xenstore( "remove", device, major, minor)
+
+    # Adds device to dictionary if not already there
+    def device_added_callback(self,udi):
+        log.debug('UDI %s was added', udi)
+        self.show_dict(self.udi_dict)
+        dev_obj = self.bus.get_object ('org.freedesktop.Hal', udi)
+        dev = dbus.Interface (dev_obj, 'org.freedesktop.Hal.Device')
+        device = dev.GetProperty ('block.device')
+        major = dev.GetProperty ('block.major')
+        minor = dev.GetProperty ('block.minor')
+        udi_info = {}
+        udi_info['device'] = device
+        udi_info['major'] = major
+        udi_info['minor'] = minor
+        udi_info['udi'] = udi
+        already = 0
+        cnt = 0;
+        for key in self.udi_dict:
+            info = self.udi_dict[key]
+            if info['udi'] == udi:
+                already = 1
+                break
+            cnt = cnt + 1
+        if already == 0:
+           self.udi_dict[cnt] = udi_info;
+           log.debug('UDI %s was added, device:%s major:%s minor:%s index:%d\n', udi, device, major, minor, cnt)
+        self.change_xenstore( "add", device, major, minor)
+
+    # Debug helper, shows dictionary contents
+    def show_dict(self,dict=None):
+        if self.debug == 0 :
+            return
+        if dict == None :
+            dict = self.udi_dict
+        for key in dict:
+            log.debug('udi_info %s udi_info:%s',key,dict[key])
+
+    # Set or clear xenstore media-present depending on the action argument
+    #  for every vbd that has this block device
+    def change_xenstore(self,action, device, major, minor):
+        for type in DEVICE_TYPES:
+            path = self.dbpath + '/' + type
+            domains = xstransact.List(path)
+            log.debug('domains: %s', domains)
+            for domain in domains:   # for each domain
+                devices = xstransact.List( path + '/' + domain)
+                log.debug('devices: %s',devices)
+                for device in devices:  # for each vbd device
+                   str = device.split('/')
+                   vbd_type = None;
+                   vbd_physical_device = None
+                   vbd_media = None
+                   vbd_device_path = path + '/' + domain + '/' + device
+                   listing = xstransact.List(vbd_device_path)
+                   for entry in listing: # for each entry
+                       item = path + '/' + entry
+                       value = xstransact.Read( vbd_device_path + '/' + entry)
+                       log.debug('%s=%s',item,value)
+                       if item.find('media-present') != -1:
+                           vbd_media = item;
+                           vbd_media_path = item
+                       if item.find('physical-device') != -1:
+                           vbd_physical_device = value;
+                       if item.find('type') != -1:
+                           vbd_type = value;
+                   if vbd_type is not None and vbd_physical_device is not None and vbd_media is not None :
+                       inode = vbd_physical_device.split(':')
+                       imajor = parse_hex(inode[0])
+                       iminor = parse_hex(inode[1])
+                       log.debug("action:%s major:%s- minor:%s- imajor:%s- iminor:%s- inode: %s",
+                               action,major,minor, imajor, iminor, inode)
+                       if int(imajor) == int(major) and int(iminor) == int(minor):
+                           if action == "add":
+                               xs_dict = {'media': "1"}
+                               xstransact.Write(vbd_device_path, 'media-present', "1" )
+                               log.debug("wrote xenstore media-present 1 path:%s",vbd_media_path)
+                           else:
+                               xstransact.Write(vbd_device_path, 'media-present', "0" )
+                               log.debug("wrote xenstore media 0 path:%s",vbd_media_path)
+
+def mylog( fmt, *args):
+    f = open('/tmp/haldaemon.log', 'a')
+    print >>f, "HalDaemon ", fmt % args
+    f.close()
+
+
+def parse_hex(val):
+    try:
+        if isinstance(val, types.StringTypes):
+            return int(val, 16)
+        else:
+            return val
+    except ValueError:
+        return None
+
+if __name__ == "__main__":
+    watcher = HalDaemon()
+    watcher.run()
+    print 'Falling off end'
+
+
diff -Naur xen/tools/python/xen/xend/server/Hald.py xen-a/tools/python/xen/xend/server/Hald.py
--- xen/tools/python/xen/xend/server/Hald.py	1969-12-31 17:00:00.000000000 -0700
+++ xen-a/tools/python/xen/xend/server/Hald.py	2014-07-08 06:10:03.136669044 -0600
@@ -0,0 +1,125 @@
+#============================================================================
+# This library is free software; you can redistribute it and/or
+# modify it under the terms of version 2.1 of the GNU Lesser General Public
+# License as published by the Free Software Foundation.
+#
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with this library; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#============================================================================
+# Copyright (C) 2007 Pat Campbell <plc@novell.com>
+# Copyright (C) 2007 Novell Inc.
+#============================================================================
+
+import errno
+import types
+import os
+import sys
+import time
+import signal
+from traceback import print_exc
+
+from xen.xend.XendLogging import log
+
+class Hald:
+    def __init__(self):
+        self.ready = False
+        self.running = True
+
+    def run(self):
+        """Starts the HalDaemon process
+        """
+        self.ready = True
+        try:
+            myfile =  self.find("xen/xend/server/HalDaemon.py")
+            args = (["python", myfile ])
+            self.pid = self.daemonize("python", args )
+            #log.debug( "%s %s pid:%d", "Hald.py starting ", args, self.pid )
+        except:
+            self.pid = -1
+            log.debug("Unable to start HalDaemon process")
+
+    def shutdown(self):
+        """Shutdown the HalDaemon process
+        """
+        log.debug("%s  pid:%d", "Hald.shutdown()", self.pid)
+        self.running = False
+        self.ready = False
+        if self.pid != -1:
+            try:
+                os.kill(self.pid, signal.SIGINT)
+            except:
+                print_exc()
+
+    def daemonize(self,prog, args):
+        """Runs a program as a daemon with the list of arguments.  Returns the PID
+        of the daemonized program, or returns 0 on error.
+        Copied from xm/create.py instead of importing to reduce coupling
+        """
+        r, w = os.pipe()
+        pid = os.fork()
+
+        if pid == 0:
+            os.close(r)
+            w = os.fdopen(w, 'w')
+            os.setsid()
+            try:
+                pid2 = os.fork()
+            except:
+                pid2 = None
+            if pid2 == 0:
+                os.chdir("/")
+                env = os.environ.copy()
+                env['PYTHONPATH'] = self.getpythonpath()
+                for fd in range(0, 256):
+                    try:
+                        os.close(fd)
+                    except:
+                        pass
+                os.open("/dev/null", os.O_RDWR)
+                os.dup2(0, 1)
+                os.dup2(0, 2)
+                os.execvpe(prog, args, env)
+                os._exit(1)
+            else:
+                w.write(str(pid2 or 0))
+                w.close()
+                os._exit(0)
+        os.close(w)
+        r = os.fdopen(r)
+        daemon_pid = int(r.read())
+        r.close()
+        os.waitpid(pid, 0)
+        #log.debug( "daemon_pid: %d", daemon_pid )
+        return daemon_pid
+
+    def getpythonpath(self):
+        str = " "
+        for p in sys.path:
+            if str != " ":
+                str = str + ":" + p
+            else:
+                if str != "":
+                   str = p
+        return str
+
+    def find(self,path, matchFunc=os.path.isfile):
+        """Find a module in the sys.path
+        From web page: http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52224
+        """
+        for dirname in sys.path:
+            candidate = os.path.join(dirname, path)
+            if matchFunc(candidate):
+                return candidate
+        raise Error("Can't find file %s" % path)
+
+if __name__ == "__main__":
+    watcher = Hald()
+    watcher.run()
+    time.sleep(10)
+    watcher.shutdown()
diff -Naur xen/unmodified_drivers/linux-2.6/platform-pci/platform-pci.c xen-a/unmodified_drivers/linux-2.6/platform-pci/platform-pci.c
--- xen/unmodified_drivers/linux-2.6/platform-pci/platform-pci.c	2014-07-07 23:11:48.513334437 -0600
+++ xen-a/unmodified_drivers/linux-2.6/platform-pci/platform-pci.c	2014-07-08 06:13:52.839999377 -0600
@@ -39,6 +39,9 @@
 #include <xen/interface/hvm/params.h>
 #include <xen/features.h>
 #include <xen/evtchn.h>
+#ifdef HAVE_XEN_PVONHVM_UNPLUG
+#include <xen/xen_pvonhvm.h>
+#endif
 #ifdef __ia64__
 #include <asm/xen/xencomm.h>
 #endif
@@ -290,6 +293,18 @@
 	short magic, unplug = 0;
 	char protocol, *p, *q, *err;
 
+#ifdef HAVE_XEN_PVONHVM_UNPLUG
+	if (xen_pvonhvm_unplug) {
+		/* Use kernel cmdline setting */
+		if (dev_unplug)
+			printk(KERN_INFO DRV_NAME ": ignoring option dev_unplug=%s \n", dev_unplug);
+		dev_unplug = NULL;
+		if (xen_pvonhvm_unplugged_disks)
+			unplug |= UNPLUG_ALL_IDE_DISKS | UNPLUG_AUX_IDE_DISKS;
+		if (xen_pvonhvm_unplugged_nics)
+			unplug |= UNPLUG_ALL_NICS;
+	} else
+#endif
 	/* Unconditionally unplug everything */
 	if (!dev_unplug)
 		unplug = UNPLUG_ALL;
diff -Naur xen/xen/arch/x86/domain.c xen-a/xen/arch/x86/domain.c
--- xen/xen/arch/x86/domain.c	2014-07-07 23:11:48.526667770 -0600
+++ xen-a/xen/arch/x86/domain.c	2014-07-08 06:12:19.719997581 -0600
@@ -151,15 +151,30 @@
 
     printk("Memory pages belonging to domain %u:\n", d->domain_id);
 
-    if ( d->tot_pages >= 10 )
+    if ( d->tot_pages >= 10 && d->is_dying < DOMDYING_dead )
     {
         printk("    DomPage list too long to display\n");
     }
     else
     {
+        unsigned long total[PGT_type_mask
+                            / (PGT_type_mask & -PGT_type_mask) + 1] = {};
+
         spin_lock(&d->page_alloc_lock);
         page_list_for_each ( page, &d->page_list )
         {
+            unsigned int index = (page->u.inuse.type_info & PGT_type_mask)
+                                 / (PGT_type_mask & -PGT_type_mask);
+
+            if ( ++total[index] > 16 )
+            {
+                switch ( page->u.inuse.type_info & PGT_type_mask )
+                {
+                case PGT_none:
+                case PGT_writable_page:
+                    continue;
+                }
+            }
             printk("    DomPage %p: caf=%08lx, taf=%" PRtype_info "\n",
                    _p(page_to_mfn(page)),
                    page->count_info, page->u.inuse.type_info);
diff -Naur xen/xen/arch/x86/hvm/stdvga.c xen-a/xen/arch/x86/hvm/stdvga.c
--- xen/xen/arch/x86/hvm/stdvga.c	2014-07-07 23:11:48.533334437 -0600
+++ xen-a/xen/arch/x86/hvm/stdvga.c	2014-07-08 06:09:39.503333915 -0600
@@ -135,7 +135,10 @@
 
     /* When in standard vga mode, emulate here all writes to the vram buffer
      * so we can immediately satisfy reads without waiting for qemu. */
-    s->stdvga = (s->sr[7] == 0x00);
+    s->stdvga =
+        (s->sr[7] == 0x00) &&  /* standard vga mode */
+        (s->gr[6] == 0x05);    /* misc graphics register w/ MemoryMapSelect=1
+                                * 0xa0000-0xaffff (64k region), AlphaDis=1 */
 
     if ( !prev_stdvga && s->stdvga )
     {
diff -Naur xen/xen/arch/x86/platform_hypercall.c xen-a/xen/arch/x86/platform_hypercall.c
--- xen/xen/arch/x86/platform_hypercall.c	2014-07-07 23:11:48.550001103 -0600
+++ xen-a/xen/arch/x86/platform_hypercall.c	2014-07-08 06:11:26.839986738 -0600
@@ -25,7 +25,7 @@
 #include <xen/irq.h>
 #include <asm/current.h>
 #include <public/platform.h>
-#include <acpi/cpufreq/processor_perf.h>
+#include <acpi/cpufreq/cpufreq.h>
 #include <asm/edd.h>
 #include <asm/mtrr.h>
 #include <asm/io_apic.h>
@@ -601,6 +601,41 @@
     }
     break;
 
+    case XENPF_get_cpu_freq:
+    case XENPF_get_cpu_freq_min:
+    case XENPF_get_cpu_freq_max:
+    {
+        struct vcpu *v;
+        const struct cpufreq_policy *policy;
+
+        if ( op->u.get_cpu_freq.vcpu >= current->domain->max_vcpus ||
+             !(v = current->domain->vcpu[op->u.get_cpu_freq.vcpu]) )
+        {
+            ret = -EINVAL;
+            break;
+        }
+
+        policy = per_cpu(cpufreq_cpu_policy, v->processor);
+        switch ( op->cmd & -!!policy )
+        {
+        case XENPF_get_cpu_freq:
+            op->u.get_cpu_freq.freq = policy->cur;
+            break;
+        case XENPF_get_cpu_freq_min:
+            op->u.get_cpu_freq.freq = policy->min;
+            break;
+        case XENPF_get_cpu_freq_max:
+            op->u.get_cpu_freq.freq = policy->max;
+            break;
+        default:
+            op->u.get_cpu_freq.freq = 0;
+            break;
+        }
+        if ( __copy_field_to_guest(u_xenpf_op, op, u.get_cpu_freq.freq) )
+            ret = -EFAULT;
+    }
+    break;
+
     default:
         ret = -ENOSYS;
         break;
diff -Naur xen/xen/include/public/io/blkif.h xen-a/xen/include/public/io/blkif.h
--- xen/xen/include/public/io/blkif.h	2014-07-07 23:11:48.603334437 -0600
+++ xen-a/xen/include/public/io/blkif.h	2014-07-08 06:14:54.263332595 -0600
@@ -485,7 +485,7 @@
  * Used in SLES sources for device specific command packet
  * contained within the request. Reserved for that purpose.
  */
-#define BLKIF_OP_RESERVED_1        4
+#define BLKIF_OP_PACKET        4
 /*
  * Indicate to the backend device that a region of storage is no longer in
  * use, and may be discarded at any time without impact to the client.  If
diff -Naur xen/xen/include/public/io/blkif.h.orig xen-a/xen/include/public/io/blkif.h.orig
--- xen/xen/include/public/io/blkif.h.orig	1969-12-31 17:00:00.000000000 -0700
+++ xen-a/xen/include/public/io/blkif.h.orig	2014-07-07 23:11:48.603334437 -0600
@@ -0,0 +1,640 @@
+/******************************************************************************
+ * blkif.h
+ *
+ * Unified block-device I/O interface for Xen guest OSes.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright (c) 2003-2004, Keir Fraser
+ * Copyright (c) 2012, Spectra Logic Corporation
+ */
+
+#ifndef __XEN_PUBLIC_IO_BLKIF_H__
+#define __XEN_PUBLIC_IO_BLKIF_H__
+
+#include "ring.h"
+#include "../grant_table.h"
+
+/*
+ * Front->back notifications: When enqueuing a new request, sending a
+ * notification can be made conditional on req_event (i.e., the generic
+ * hold-off mechanism provided by the ring macros). Backends must set
+ * req_event appropriately (e.g., using RING_FINAL_CHECK_FOR_REQUESTS()).
+ *
+ * Back->front notifications: When enqueuing a new response, sending a
+ * notification can be made conditional on rsp_event (i.e., the generic
+ * hold-off mechanism provided by the ring macros). Frontends must set
+ * rsp_event appropriately (e.g., using RING_FINAL_CHECK_FOR_RESPONSES()).
+ */
+
+#ifndef blkif_vdev_t
+#define blkif_vdev_t   uint16_t
+#endif
+#define blkif_sector_t uint64_t
+
+/*
+ * Feature and Parameter Negotiation
+ * =================================
+ * The two halves of a Xen block driver utilize nodes within the XenStore to
+ * communicate capabilities and to negotiate operating parameters.  This
+ * section enumerates these nodes which reside in the respective front and
+ * backend portions of the XenStore, following the XenBus convention.
+ *
+ * All data in the XenStore is stored as strings.  Nodes specifying numeric
+ * values are encoded in decimal.  Integer value ranges listed below are
+ * expressed as fixed sized integer types capable of storing the conversion
+ * of a properly formated node string, without loss of information.
+ *
+ * Any specified default value is in effect if the corresponding XenBus node
+ * is not present in the XenStore.
+ *
+ * XenStore nodes in sections marked "PRIVATE" are solely for use by the
+ * driver side whose XenBus tree contains them.
+ *
+ * XenStore nodes marked "DEPRECATED" in their notes section should only be
+ * used to provide interoperability with legacy implementations.
+ *
+ * See the XenBus state transition diagram below for details on when XenBus
+ * nodes must be published and when they can be queried.
+ *
+ *****************************************************************************
+ *                            Backend XenBus Nodes
+ *****************************************************************************
+ *
+ *------------------ Backend Device Identification (PRIVATE) ------------------
+ *
+ * mode
+ *      Values:         "r" (read only), "w" (writable)
+ *
+ *      The read or write access permissions to the backing store to be
+ *      granted to the frontend.
+ *
+ * params
+ *      Values:         string
+ *
+ *      A free formatted string providing sufficient information for the
+ *      backend driver to open the backing device.  (e.g. the path to the
+ *      file or block device representing the backing store.)
+ *
+ * type
+ *      Values:         "file", "phy", "tap"
+ *
+ *      The type of the backing device/object.
+ *
+ *
+ * direct-io-safe
+ *      Values:         0/1 (boolean)
+ *      Default Value:  0
+ *
+ *      The underlying storage is not affected by the direct IO memory
+ *      lifetime bug.  See:
+ *        http://lists.xen.org/archives/html/xen-devel/2012-12/msg01154.html
+ *
+ *      Therefore this option gives the backend permission to use
+ *      O_DIRECT, notwithstanding that bug.
+ *
+ *      That is, if this option is enabled, use of O_DIRECT is safe,
+ *      in circumstances where we would normally have avoided it as a
+ *      workaround for that bug.  This option is not relevant for all
+ *      backends, and even not necessarily supported for those for
+ *      which it is relevant.  A backend which knows that it is not
+ *      affected by the bug can ignore this option.
+ *
+ *      This option doesn't require a backend to use O_DIRECT, so it
+ *      should not be used to try to control the caching behaviour.
+ *
+ *--------------------------------- Features ---------------------------------
+ *
+ * feature-barrier
+ *      Values:         0/1 (boolean)
+ *      Default Value:  0
+ *
+ *      A value of "1" indicates that the backend can process requests
+ *      containing the BLKIF_OP_WRITE_BARRIER request opcode.  Requests
+ *      of this type may still be returned at any time with the
+ *      BLKIF_RSP_EOPNOTSUPP result code.
+ *
+ * feature-flush-cache
+ *      Values:         0/1 (boolean)
+ *      Default Value:  0
+ *
+ *      A value of "1" indicates that the backend can process requests
+ *      containing the BLKIF_OP_FLUSH_DISKCACHE request opcode.  Requests
+ *      of this type may still be returned at any time with the
+ *      BLKIF_RSP_EOPNOTSUPP result code.
+ *
+ * feature-discard
+ *      Values:         0/1 (boolean)
+ *      Default Value:  0
+ *
+ *      A value of "1" indicates that the backend can process requests
+ *      containing the BLKIF_OP_DISCARD request opcode.  Requests
+ *      of this type may still be returned at any time with the
+ *      BLKIF_RSP_EOPNOTSUPP result code.
+ *
+ * feature-persistent
+ *      Values:         0/1 (boolean)
+ *      Default Value:  0
+ *      Notes: 7
+ *
+ *      A value of "1" indicates that the backend can keep the grants used
+ *      by the frontend driver mapped, so the same set of grants should be
+ *      used in all transactions. The maximum number of grants the backend
+ *      can map persistently depends on the implementation, but ideally it
+ *      should be RING_SIZE * BLKIF_MAX_SEGMENTS_PER_REQUEST. Using this
+ *      feature the backend doesn't need to unmap each grant, preventing
+ *      costly TLB flushes. The backend driver should only map grants
+ *      persistently if the frontend supports it. If a backend driver chooses
+ *      to use the persistent protocol when the frontend doesn't support it,
+ *      it will probably hit the maximum number of persistently mapped grants
+ *      (due to the fact that the frontend won't be reusing the same grants),
+ *      and fall back to non-persistent mode. Backend implementations may
+ *      shrink or expand the number of persistently mapped grants without
+ *      notifying the frontend depending on memory constraints (this might
+ *      cause a performance degradation).
+ *
+ *      If a backend driver wants to limit the maximum number of persistently
+ *      mapped grants to a value less than RING_SIZE *
+ *      BLKIF_MAX_SEGMENTS_PER_REQUEST a LRU strategy should be used to
+ *      discard the grants that are less commonly used. Using a LRU in the
+ *      backend driver paired with a LIFO queue in the frontend will
+ *      allow us to have better performance in this scenario.
+ *
+ *----------------------- Request Transport Parameters ------------------------
+ *
+ * max-ring-page-order
+ *      Values:         <uint32_t>
+ *      Default Value:  0
+ *      Notes:          1, 3
+ *
+ *      The maximum supported size of the request ring buffer in units of
+ *      lb(machine pages). (e.g. 0 == 1 page,  1 = 2 pages, 2 == 4 pages,
+ *      etc.).
+ *
+ * max-ring-pages
+ *      Values:         <uint32_t>
+ *      Default Value:  1
+ *      Notes:          DEPRECATED, 2, 3
+ *
+ *      The maximum supported size of the request ring buffer in units of
+ *      machine pages.  The value must be a power of 2.
+ *
+ *------------------------- Backend Device Properties -------------------------
+ *
+ * discard-enable
+ *      Values:         0/1 (boolean)
+ *      Default Value:  1
+ *
+ *      This optional property, set by the toolstack, instructs the backend
+ *      to offer discard to the frontend. If the property is missing the
+ *      backend should offer discard if the backing storage actually supports
+ *      it. This optional property, set by the toolstack, requests that the
+ *      backend offer, or not offer, discard to the frontend.
+ *
+ * discard-alignment
+ *      Values:         <uint32_t>
+ *      Default Value:  0
+ *      Notes:          4, 5
+ *
+ *      The offset, in bytes from the beginning of the virtual block device,
+ *      to the first, addressable, discard extent on the underlying device.
+ *
+ * discard-granularity
+ *      Values:         <uint32_t>
+ *      Default Value:  <"sector-size">
+ *      Notes:          4
+ *
+ *      The size, in bytes, of the individually addressable discard extents
+ *      of the underlying device.
+ *
+ * discard-secure
+ *      Values:         0/1 (boolean)
+ *      Default Value:  0
+ *      Notes:          10
+ *
+ *      A value of "1" indicates that the backend can process BLKIF_OP_DISCARD
+ *      requests with the BLKIF_DISCARD_SECURE flag set.
+ *
+ * info
+ *      Values:         <uint32_t> (bitmap)
+ *
+ *      A collection of bit flags describing attributes of the backing
+ *      device.  The VDISK_* macros define the meaning of each bit
+ *      location.
+ *
+ * sector-size
+ *      Values:         <uint32_t>
+ *
+ *      The logical sector size, in bytes, of the backend device.
+ *
+ * physical-sector-size
+ *      Values:         <uint32_t>
+ *
+ *      The physical sector size, in bytes, of the backend device.
+ *
+ * sectors
+ *      Values:         <uint64_t>
+ *
+ *      The size of the backend device, expressed in units of its logical
+ *      sector size ("sector-size").
+ *
+ *****************************************************************************
+ *                            Frontend XenBus Nodes
+ *****************************************************************************
+ *
+ *----------------------- Request Transport Parameters -----------------------
+ *
+ * event-channel
+ *      Values:         <uint32_t>
+ *
+ *      The identifier of the Xen event channel used to signal activity
+ *      in the ring buffer.
+ *
+ * ring-ref
+ *      Values:         <uint32_t>
+ *      Notes:          6
+ *
+ *      The Xen grant reference granting permission for the backend to map
+ *      the sole page in a single page sized ring buffer.
+ *
+ * ring-ref%u
+ *      Values:         <uint32_t>
+ *      Notes:          6
+ *
+ *      For a frontend providing a multi-page ring, a "number of ring pages"
+ *      sized list of nodes, each containing a Xen grant reference granting
+ *      permission for the backend to map the page of the ring located
+ *      at page index "%u".  Page indexes are zero based.
+ *
+ * protocol
+ *      Values:         string (XEN_IO_PROTO_ABI_*)
+ *      Default Value:  XEN_IO_PROTO_ABI_NATIVE
+ *
+ *      The machine ABI rules governing the format of all ring request and
+ *      response structures.
+ *
+ * ring-page-order
+ *      Values:         <uint32_t>
+ *      Default Value:  0
+ *      Maximum Value:  MAX(ffs(max-ring-pages) - 1, max-ring-page-order)
+ *      Notes:          1, 3
+ *
+ *      The size of the frontend allocated request ring buffer in units
+ *      of lb(machine pages). (e.g. 0 == 1 page, 1 = 2 pages, 2 == 4 pages,
+ *      etc.).
+ *
+ * num-ring-pages
+ *      Values:         <uint32_t>
+ *      Default Value:  1
+ *      Maximum Value:  MAX(max-ring-pages,(0x1 << max-ring-page-order))
+ *      Notes:          DEPRECATED, 2, 3
+ *
+ *      The size of the frontend allocated request ring buffer in units of
+ *      machine pages.  The value must be a power of 2.
+ *
+ * feature-persistent
+ *      Values:         0/1 (boolean)
+ *      Default Value:  0
+ *      Notes: 7, 8, 9
+ *
+ *      A value of "1" indicates that the frontend will reuse the same grants
+ *      for all transactions, allowing the backend to map them with write
+ *      access (even when it should be read-only). If the frontend hits the
+ *      maximum number of allowed persistently mapped grants, it can fallback
+ *      to non persistent mode. This will cause a performance degradation,
+ *      since the the backend driver will still try to map those grants
+ *      persistently. Since the persistent grants protocol is compatible with
+ *      the previous protocol, a frontend driver can choose to work in
+ *      persistent mode even when the backend doesn't support it.
+ *
+ *      It is recommended that the frontend driver stores the persistently
+ *      mapped grants in a LIFO queue, so a subset of all persistently mapped
+ *      grants gets used commonly. This is done in case the backend driver
+ *      decides to limit the maximum number of persistently mapped grants
+ *      to a value less than RING_SIZE * BLKIF_MAX_SEGMENTS_PER_REQUEST.
+ *
+ *------------------------- Virtual Device Properties -------------------------
+ *
+ * device-type
+ *      Values:         "disk", "cdrom", "floppy", etc.
+ *
+ * virtual-device
+ *      Values:         <uint32_t>
+ *
+ *      A value indicating the physical device to virtualize within the
+ *      frontend's domain.  (e.g. "The first ATA disk", "The third SCSI
+ *      disk", etc.)
+ *
+ *      See docs/misc/vbd-interface.txt for details on the format of this
+ *      value.
+ *
+ * Notes
+ * -----
+ * (1) Multi-page ring buffer scheme first developed in the Citrix XenServer
+ *     PV drivers.
+ * (2) Multi-page ring buffer scheme first used in some RedHat distributions
+ *     including a distribution deployed on certain nodes of the Amazon
+ *     EC2 cluster.
+ * (3) Support for multi-page ring buffers was implemented independently,
+ *     in slightly different forms, by both Citrix and RedHat/Amazon.
+ *     For full interoperability, block front and backends should publish
+ *     identical ring parameters, adjusted for unit differences, to the
+ *     XenStore nodes used in both schemes.
+ * (4) Devices that support discard functionality may internally allocate space
+ *     (discardable extents) in units that are larger than the exported logical
+ *     block size. If the backing device has such discardable extents the
+ *     backend should provide both discard-granularity and discard-alignment.
+ *     Providing just one of the two may be considered an error by the frontend.
+ *     Backends supporting discard should include discard-granularity and
+ *     discard-alignment even if it supports discarding individual sectors.
+ *     Frontends should assume discard-alignment == 0 and discard-granularity
+ *     == sector size if these keys are missing.
+ * (5) The discard-alignment parameter allows a physical device to be
+ *     partitioned into virtual devices that do not necessarily begin or
+ *     end on a discardable extent boundary.
+ * (6) When there is only a single page allocated to the request ring,
+ *     'ring-ref' is used to communicate the grant reference for this
+ *     page to the backend.  When using a multi-page ring, the 'ring-ref'
+ *     node is not created.  Instead 'ring-ref0' - 'ring-refN' are used.
+ * (7) When using persistent grants data has to be copied from/to the page
+ *     where the grant is currently mapped. The overhead of doing this copy
+ *     however doesn't suppress the speed improvement of not having to unmap
+ *     the grants.
+ * (8) The frontend driver has to allow the backend driver to map all grants
+ *     with write access, even when they should be mapped read-only, since
+ *     further requests may reuse these grants and require write permissions.
+ * (9) Linux implementation doesn't have a limit on the maximum number of
+ *     grants that can be persistently mapped in the frontend driver, but
+ *     due to the frontent driver implementation it should never be bigger
+ *     than RING_SIZE * BLKIF_MAX_SEGMENTS_PER_REQUEST.
+ *(10) The discard-secure property may be present and will be set to 1 if the
+ *     backing device supports secure discard.
+ */
+
+/*
+ * STATE DIAGRAMS
+ *
+ *****************************************************************************
+ *                                   Startup                                 *
+ *****************************************************************************
+ *
+ * Tool stack creates front and back nodes with state XenbusStateInitialising.
+ *
+ * Front                                Back
+ * =================================    =====================================
+ * XenbusStateInitialising              XenbusStateInitialising
+ *  o Query virtual device               o Query backend device identification
+ *    properties.                          data.
+ *  o Setup OS device instance.          o Open and validate backend device.
+ *                                       o Publish backend features and
+ *                                         transport parameters.
+ *                                                      |
+ *                                                      |
+ *                                                      V
+ *                                      XenbusStateInitWait
+ *
+ * o Query backend features and
+ *   transport parameters.
+ * o Allocate and initialize the
+ *   request ring.
+ * o Publish transport parameters
+ *   that will be in effect during
+ *   this connection.
+ *              |
+ *              |
+ *              V
+ * XenbusStateInitialised
+ *
+ *                                       o Query frontend transport parameters.
+ *                                       o Connect to the request ring and
+ *                                         event channel.
+ *                                       o Publish backend device properties.
+ *                                                      |
+ *                                                      |
+ *                                                      V
+ *                                      XenbusStateConnected
+ *
+ *  o Query backend device properties.
+ *  o Finalize OS virtual device
+ *    instance.
+ *              |
+ *              |
+ *              V
+ * XenbusStateConnected
+ *
+ * Note: Drivers that do not support any optional features, or the negotiation
+ *       of transport parameters, can skip certain states in the state machine:
+ *
+ *       o A frontend may transition to XenbusStateInitialised without
+ *         waiting for the backend to enter XenbusStateInitWait.  In this
+ *         case, default transport parameters are in effect and any
+ *         transport parameters published by the frontend must contain
+ *         their default values.
+ *
+ *       o A backend may transition to XenbusStateInitialised, bypassing
+ *         XenbusStateInitWait, without waiting for the frontend to first
+ *         enter the XenbusStateInitialised state.  In this case, default
+ *         transport parameters are in effect and any transport parameters
+ *         published by the backend must contain their default values.
+ *
+ *       Drivers that support optional features and/or transport parameter
+ *       negotiation must tolerate these additional state transition paths.
+ *       In general this means performing the work of any skipped state
+ *       transition, if it has not already been performed, in addition to the
+ *       work associated with entry into the current state.
+ */
+
+/*
+ * REQUEST CODES.
+ */
+#define BLKIF_OP_READ              0
+#define BLKIF_OP_WRITE             1
+/*
+ * All writes issued prior to a request with the BLKIF_OP_WRITE_BARRIER
+ * operation code ("barrier request") must be completed prior to the
+ * execution of the barrier request.  All writes issued after the barrier
+ * request must not execute until after the completion of the barrier request.
+ *
+ * Optional.  See "feature-barrier" XenBus node documentation above.
+ */
+#define BLKIF_OP_WRITE_BARRIER     2
+/*
+ * Commit any uncommitted contents of the backing device's volatile cache
+ * to stable storage.
+ *
+ * Optional.  See "feature-flush-cache" XenBus node documentation above.
+ */
+#define BLKIF_OP_FLUSH_DISKCACHE   3
+/*
+ * Used in SLES sources for device specific command packet
+ * contained within the request. Reserved for that purpose.
+ */
+#define BLKIF_OP_RESERVED_1        4
+/*
+ * Indicate to the backend device that a region of storage is no longer in
+ * use, and may be discarded at any time without impact to the client.  If
+ * the BLKIF_DISCARD_SECURE flag is set on the request, all copies of the
+ * discarded region on the device must be rendered unrecoverable before the
+ * command returns.
+ *
+ * This operation is analogous to performing a trim (ATA) or unamp (SCSI),
+ * command on a native device.
+ *
+ * More information about trim/unmap operations can be found at:
+ * http://t13.org/Documents/UploadedDocuments/docs2008/
+ *     e07154r6-Data_Set_Management_Proposal_for_ATA-ACS2.doc
+ * http://www.seagate.com/staticfiles/support/disc/manuals/
+ *     Interface%20manuals/100293068c.pdf
+ *
+ * Optional.  See "feature-discard", "discard-alignment",
+ * "discard-granularity", and "discard-secure" in the XenBus node
+ * documentation above.
+ */
+#define BLKIF_OP_DISCARD           5
+
+/*
+ * Recognized if "feature-max-indirect-segments" in present in the backend
+ * xenbus info. The "feature-max-indirect-segments" node contains the maximum
+ * number of segments allowed by the backend per request. If the node is
+ * present, the frontend might use blkif_request_indirect structs in order to
+ * issue requests with more than BLKIF_MAX_SEGMENTS_PER_REQUEST (11). The
+ * maximum number of indirect segments is fixed by the backend, but the
+ * frontend can issue requests with any number of indirect segments as long as
+ * it's less than the number provided by the backend. The indirect_grefs field
+ * in blkif_request_indirect should be filled by the frontend with the
+ * grant references of the pages that are holding the indirect segments.
+ * These pages are filled with an array of blkif_request_segment that hold the
+ * information about the segments. The number of indirect pages to use is
+ * determined by the number of segments an indirect request contains. Every
+ * indirect page can contain a maximum of
+ * (PAGE_SIZE / sizeof(struct blkif_request_segment)) segments, so to
+ * calculate the number of indirect pages to use we have to do
+ * ceil(indirect_segments / (PAGE_SIZE / sizeof(struct blkif_request_segment))).
+ *
+ * If a backend does not recognize BLKIF_OP_INDIRECT, it should *not*
+ * create the "feature-max-indirect-segments" node!
+ */
+#define BLKIF_OP_INDIRECT          6
+
+/*
+ * Maximum scatter/gather segments per request.
+ * This is carefully chosen so that sizeof(blkif_ring_t) <= PAGE_SIZE.
+ * NB. This could be 12 if the ring indexes weren't stored in the same page.
+ */
+#define BLKIF_MAX_SEGMENTS_PER_REQUEST 11
+
+/*
+ * Maximum number of indirect pages to use per request.
+ */
+#define BLKIF_MAX_INDIRECT_PAGES_PER_REQUEST 8
+
+/*
+ * NB. first_sect and last_sect in blkif_request_segment, as well as
+ * sector_number in blkif_request, are always expressed in 512-byte units.
+ * However they must be properly aligned to the real sector size of the
+ * physical disk, which is reported in the "physical-sector-size" node in
+ * the backend xenbus info. Also the xenbus "sectors" node is expressed in
+ * 512-byte units.
+ */
+struct blkif_request_segment {
+    grant_ref_t gref;        /* reference to I/O buffer frame        */
+    /* @first_sect: first sector in frame to transfer (inclusive).   */
+    /* @last_sect: last sector in frame to transfer (inclusive).     */
+    uint8_t     first_sect, last_sect;
+};
+
+/*
+ * Starting ring element for any I/O request.
+ */
+struct blkif_request {
+    uint8_t        operation;    /* BLKIF_OP_???                         */
+    uint8_t        nr_segments;  /* number of segments                   */
+    blkif_vdev_t   handle;       /* only for read/write requests         */
+    uint64_t       id;           /* private guest value, echoed in resp  */
+    blkif_sector_t sector_number;/* start sector idx on disk (r/w only)  */
+    struct blkif_request_segment seg[BLKIF_MAX_SEGMENTS_PER_REQUEST];
+};
+typedef struct blkif_request blkif_request_t;
+
+/*
+ * Cast to this structure when blkif_request.operation == BLKIF_OP_DISCARD
+ * sizeof(struct blkif_request_discard) <= sizeof(struct blkif_request)
+ */
+struct blkif_request_discard {
+    uint8_t        operation;    /* BLKIF_OP_DISCARD                     */
+    uint8_t        flag;         /* BLKIF_DISCARD_SECURE or zero         */
+#define BLKIF_DISCARD_SECURE (1<<0)  /* ignored if discard-secure=0      */
+    blkif_vdev_t   handle;       /* same as for read/write requests      */
+    uint64_t       id;           /* private guest value, echoed in resp  */
+    blkif_sector_t sector_number;/* start sector idx on disk             */
+    uint64_t       nr_sectors;   /* number of contiguous sectors to discard*/
+};
+typedef struct blkif_request_discard blkif_request_discard_t;
+
+struct blkif_request_indirect {
+    uint8_t        operation;    /* BLKIF_OP_INDIRECT                    */
+    uint8_t        indirect_op;  /* BLKIF_OP_{READ/WRITE}                */
+    uint16_t       nr_segments;  /* number of segments                   */
+    uint64_t       id;           /* private guest value, echoed in resp  */
+    blkif_sector_t sector_number;/* start sector idx on disk (r/w only)  */
+    blkif_vdev_t   handle;       /* same as for read/write requests      */
+    grant_ref_t    indirect_grefs[BLKIF_MAX_INDIRECT_PAGES_PER_REQUEST];
+#ifdef __i386__
+    uint64_t       pad;          /* Make it 64 byte aligned on i386      */
+#endif
+};
+typedef struct blkif_request_indirect blkif_request_indirect_t;
+
+struct blkif_response {
+    uint64_t        id;              /* copied from request */
+    uint8_t         operation;       /* copied from request */
+    int16_t         status;          /* BLKIF_RSP_???       */
+};
+typedef struct blkif_response blkif_response_t;
+
+/*
+ * STATUS RETURN CODES.
+ */
+ /* Operation not supported (only happens on barrier writes). */
+#define BLKIF_RSP_EOPNOTSUPP  -2
+ /* Operation failed for some unspecified reason (-EIO). */
+#define BLKIF_RSP_ERROR       -1
+ /* Operation completed successfully. */
+#define BLKIF_RSP_OKAY         0
+
+/*
+ * Generate blkif ring structures and types.
+ */
+DEFINE_RING_TYPES(blkif, struct blkif_request, struct blkif_response);
+
+#define VDISK_CDROM        0x1
+#define VDISK_REMOVABLE    0x2
+#define VDISK_READONLY     0x4
+
+#endif /* __XEN_PUBLIC_IO_BLKIF_H__ */
+
+/*
+ * Local variables:
+ * mode: C
+ * c-file-style: "BSD"
+ * c-basic-offset: 4
+ * tab-width: 4
+ * indent-tabs-mode: nil
+ * End:
+ */
diff -Naur xen/xen/include/public/io/cdromif.h xen-a/xen/include/public/io/cdromif.h
--- xen/xen/include/public/io/cdromif.h	1969-12-31 17:00:00.000000000 -0700
+++ xen-a/xen/include/public/io/cdromif.h	2014-07-08 06:14:54.263332595 -0600
@@ -0,0 +1,122 @@
+/******************************************************************************
+ * cdromif.h
+ *
+ * Shared definitions between backend driver and Xen guest Virtual CDROM
+ * block device.
+ *
+ * Copyright (c) 2008, Pat Campell  plc@novell.com
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this source file (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef __XEN_PUBLIC_IO_CDROMIF_H__
+#define __XEN_PUBLIC_IO_CDROMIF_H__
+
+#include <linux/cdrom.h>
+
+/*
+ * Queries backend for CDROM support
+ */
+#define XEN_TYPE_CDROM_SUPPORT         _IO('c', 1)
+
+struct xen_cdrom_support
+{
+	uint32_t type;
+	int8_t ret;                  /* returned, 0 succeded, -1 error */
+	int8_t err;                  /* returned, backend errno */
+	int8_t supported;            /* returned, 1 supported */
+};
+
+/*
+ * Opens backend device, returns drive geometry or
+ * any encountered errors
+ */
+#define XEN_TYPE_CDROM_OPEN            _IO('c', 2)
+
+struct xen_cdrom_open
+{
+	uint32_t type;
+	int8_t ret;
+	int8_t err;
+	int8_t pad;
+	int8_t media_present;        /* returned */
+	uint32_t sectors;            /* returned */
+	uint32_t sector_size;        /* returned */
+	int32_t payload_offset;      /* offset to backend node name payload */
+};
+
+/*
+ * Queries backend for media changed status
+ */
+#define XEN_TYPE_CDROM_MEDIA_CHANGED   _IO('c', 3)
+
+struct xen_cdrom_media_changed
+{
+	uint32_t type;
+	int8_t ret;
+	int8_t err;
+	int8_t media_changed;        /* returned */
+};
+
+/*
+ * Sends vcd generic CDROM packet to backend, followed
+ * immediately by the vcd_generic_command payload
+ */
+#define XEN_TYPE_CDROM_PACKET          _IO('c', 4)
+
+struct xen_cdrom_packet
+{
+	uint32_t type;
+	int8_t ret;
+	int8_t err;
+	int8_t pad[2];
+	int32_t payload_offset;      /* offset to struct vcd_generic_command payload */
+};
+
+/* CDROM_PACKET_COMMAND, payload for XEN_TYPE_CDROM_PACKET */
+struct vcd_generic_command
+{
+	uint8_t  cmd[CDROM_PACKET_SIZE];
+	uint8_t  pad[4];
+	uint32_t buffer_offset;
+	uint32_t buflen;
+	int32_t  stat;
+	uint32_t sense_offset;
+	uint8_t  data_direction;
+	uint8_t  pad1[3];
+	int32_t  quiet;
+	int32_t  timeout;
+};
+
+union xen_block_packet
+{
+	uint32_t type;
+	struct xen_cdrom_support xcs;
+	struct xen_cdrom_open xco;
+	struct xen_cdrom_media_changed xcmc;
+	struct xen_cdrom_packet xcp;
+};
+
+#define PACKET_PAYLOAD_OFFSET (sizeof(struct xen_cdrom_packet))
+#define PACKET_SENSE_OFFSET (PACKET_PAYLOAD_OFFSET + sizeof(struct vcd_generic_command))
+#define PACKET_BUFFER_OFFSET (PACKET_SENSE_OFFSET + sizeof(struct request_sense))
+#define MAX_PACKET_DATA (PAGE_SIZE - sizeof(struct xen_cdrom_packet) - \
+            sizeof(struct vcd_generic_command) - sizeof(struct request_sense))
+
+#endif
diff -Naur xen/xen/include/public/platform.h xen-a/xen/include/public/platform.h
--- xen/xen/include/public/platform.h	2014-07-07 23:11:48.603334437 -0600
+++ xen-a/xen/include/public/platform.h	2014-07-08 06:11:26.839986738 -0600
@@ -527,6 +527,16 @@
 typedef struct xenpf_core_parking xenpf_core_parking_t;
 DEFINE_XEN_GUEST_HANDLE(xenpf_core_parking_t);
 
+#define XENPF_get_cpu_freq        ('N' << 24)
+#define XENPF_get_cpu_freq_min    (XENPF_get_cpu_freq + 1)
+#define XENPF_get_cpu_freq_max    (XENPF_get_cpu_freq_min + 1)
+struct xenpf_get_cpu_freq {
+    /* IN variables */
+    uint32_t vcpu;
+    /* OUT variables */
+    uint32_t freq; /* in kHz */
+};
+
 /*
  * ` enum neg_errnoval
  * ` HYPERVISOR_platform_op(const struct xen_platform_op*);
@@ -553,6 +563,7 @@
         struct xenpf_cpu_hotadd        cpu_add;
         struct xenpf_mem_hotadd        mem_add;
         struct xenpf_core_parking      core_parking;
+        struct xenpf_get_cpu_freq      get_cpu_freq;
         uint8_t                        pad[128];
     } u;
 };
